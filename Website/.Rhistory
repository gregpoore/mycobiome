write.csv(snmDataSampleTypeWithExpStrategyFAS1, file = "./AA_Data/Kraken-TCGA-50-50-Validation-Split-1-Voom-SNM-Data.csv")
write.csv(snmDataSampleTypeWithExpStrategyFAS2, file = "./AA_Data/Kraken-TCGA-50-50-Validation-Split-2-Voom-SNM-Data.csv")
write.csv(vbDataBarnDFReconciled, file = "./AA_Data/Kraken-TCGA-Raw-Data-18116-Samples.csv")
write.csv(metadataSamplesAll, file = "./AA_Data/Metadata-TCGA-All-18116-Samples.csv")
?confusionMatrix
require(ggplot2)
require(snm)
require(limma)
require(edgeR)
require(dplyr)
require(edgeR)
require(pvca)
require(lme4)
require(ggsci)
require(cowplot)
require(doMC)
require(splitstackshape)
# Load dependencies
require(devtools)
require(doMC)
require(tibble)
require(gbm)
require(splitstackshape)
require(reshape2)
require(ggpubr)
require(caret) # for model building
require(pROC) # for AUC calculations
require(purrr) # for functional programming using map()
require(dplyr) # for data manipulation
require(doMC) # for parallel computing
require(gbm) # for machine learning
require(tibble) # for df operations
require(cowplot) # for plotting
require(PRROC) # for precision-recall curves
require(MLmetrics) # for multi-class learning
require(caret) # for machine learning
?confusionMatrix
setwd("~/Google Drive/AAA_UCSD_Research/AAA_Knight_Lab/AAA_Projects/AAA_TCGA/AAA_Final_Analysis/AA_Plasma_Analysis")
## Load data
load("snmCfdnaShogunAndMetadata_Dec2_Final.RData")
load("snmKrakenAndMetadataFiltered_Dec2_Final.RData")
# TESTING-Feb262020-ConfusionMatrixCorrection.R
# Greg Poore
# Feb 26 2020
# Purpose: To correct confusion matrices in Fig. 4
## Load data
load("snmCfdnaShogunAndMetadata_Dec2_Final.RData")
load("snmKrakenAndMetadataFiltered_Dec2_Final.RData")
# Load dependencies
require(devtools)
require(doMC)
require(tibble)
require(gbm)
require(splitstackshape)
require(reshape2)
require(ggpubr)
require(caret) # for model building
require(pROC) # for AUC calculations
require(purrr) # for functional programming using map()
require(dplyr) # for data manipulation
require(doMC) # for parallel computing
require(gbm) # for machine learning
require(tibble) # for df operations
require(cowplot) # for plotting
require(PRROC) # for precision-recall curves
require(MLmetrics) # for multi-class learning
require(caret) # for machine learning
defaultGBMGrid <-  expand.grid(interaction.depth = seq(1,3),
n.trees = floor((1:3) * 50),
shrinkage = 0.1,
n.minobsinnode = 5)
customGBMGrid <-  expand.grid(interaction.depth = seq(1,3),
n.trees = floor((1:3) * 50),
shrinkage = 0.1,
n.minobsinnode = 1)
numKFold <- 4
numResampleIter <- 1
# TESTING-Feb262020-ConfusionMatrixCorrection.R
# Greg Poore
# Feb 26 2020
# Purpose: To correct confusion matrices in Fig. 4
## Load data
load("snmCfdnaShogunAndMetadata_Dec2_Final.RData")
load("snmKrakenAndMetadataFiltered_Dec2_Final.RData")
# Load dependencies
require(devtools)
require(doMC)
require(tibble)
require(gbm)
require(splitstackshape)
require(reshape2)
require(ggpubr)
require(caret) # for model building
require(pROC) # for AUC calculations
require(purrr) # for functional programming using map()
require(dplyr) # for data manipulation
require(doMC) # for parallel computing
require(gbm) # for machine learning
require(tibble) # for df operations
require(cowplot) # for plotting
require(PRROC) # for precision-recall curves
require(MLmetrics) # for multi-class learning
require(caret) # for machine learning
defaultGBMGrid <-  expand.grid(interaction.depth = seq(1,3),
n.trees = floor((1:3) * 50),
shrinkage = 0.1,
n.minobsinnode = 5)
customGBMGrid <-  expand.grid(interaction.depth = seq(1,3),
n.trees = floor((1:3) * 50),
shrinkage = 0.1,
n.minobsinnode = 1)
numKFold <- 4
numResampleIter <- 1
setwd("~/Google Drive/AAA_UCSD_Research/AAA_Knight_Lab/AAA_Projects/AAA_TCGA/AAA_Final_Analysis/AA_Plasma_Analysis/AA_TESTING_Feb262020")
## Load data
load("snmCfdnaShogunAndMetadata_Dec2_Final.RData")
load("snmKrakenAndMetadataFiltered_Dec2_Final.RData")
# Load dependencies
require(devtools)
require(doMC)
require(tibble)
require(gbm)
require(splitstackshape)
require(reshape2)
require(ggpubr)
require(caret) # for model building
require(pROC) # for AUC calculations
require(purrr) # for functional programming using map()
require(dplyr) # for data manipulation
require(doMC) # for parallel computing
require(gbm) # for machine learning
require(tibble) # for df operations
require(cowplot) # for plotting
require(PRROC) # for precision-recall curves
require(MLmetrics) # for multi-class learning
require(caret) # for machine learning
defaultGBMGrid <-  expand.grid(interaction.depth = seq(1,3),
n.trees = floor((1:3) * 50),
shrinkage = 0.1,
n.minobsinnode = 5)
customGBMGrid <-  expand.grid(interaction.depth = seq(1,3),
n.trees = floor((1:3) * 50),
shrinkage = 0.1,
n.minobsinnode = 1)
numKFold <- 4
numResampleIter <- 1
loocvDTs <- function(snmData, samplingSize = 15, DTs, caretTuneGrid = defaultGBMGrid,
filenameString = paste(DTs,collapse = "__"), HvsCFlag = FALSE){
if(HvsCFlag){
metaTmpX <- droplevels(metadataPSMatchedDPQCFiltered[(metadataPSMatchedDPQCFiltered$disease_type_consol %in% DTs),])
metaTmpX$disease_type_consol <- metaTmpX$HvsC
classes <- gsub(" ","",levels(metaTmpX$disease_type_consol))
} else{
metaTmpX <- droplevels(metadataPSMatchedDPQCFiltered[(metadataPSMatchedDPQCFiltered$disease_type_consol %in% DTs),])
classes <- gsub(" ","",DTs)
}
# Do LOOCV model building and testing
multiClassSummaryStats <- list()
multiClassSummaryStatsDist <- list()
numKFold <- 4
numResampleIter <- 1
metaData <- metaTmpX
snmData <- snmData # dataPSUniqueDecontamQC #
iterSize <- 1
for(jj in 1:iterSize){
metadataSimSampled <- as.data.frame(stratified(metaData,
group = "disease_type_consol",
size = samplingSize,
keep.rownames = TRUE,
replace = FALSE,
bothSets = FALSE))
rownames(metadataSimSampled) <- metadataSimSampled$rn
mlDataY <- metadataSimSampled
mlDataX <- snmData[rownames(mlDataY),]
dim(mlDataY)[1] == dim(mlDataX)[1] # Sanity check
# Create data partitions
# set.seed(42)
indexSuper <- 1:dim(mlDataY)[1]
predProbs <- list()
obsClass <- vector()
predClass <- vector()
varImpBestModelDF2OrderedNonzeroList <- list()
for(ii in 1:length(indexSuper)){
print(sprintf("Iteration: %d/%d", ii, length(indexSuper)))
index <- indexSuper[ii]
# print(index)
trainX <- mlDataX[-index,]
trainY <- mlDataY[-index,]$disease_type_consol
testX <- mlDataX[index,,drop=FALSE]
testY <- mlDataY[index,,drop=FALSE]$disease_type_consol
# print(testY)
refactoredTrainY <- factor(gsub('([[:punct:]])|\\s+','',trainY))
refactoredTestY <- factor(gsub('([[:punct:]])|\\s+','',testY))
obsClass[ii] <- as.character(refactoredTestY)
set.seed(42)
ctrl <- trainControl(method = "repeatedcv",
number = numKFold,
repeats = numResampleIter,
sampling = "up",
summaryFunction = multiClassSummary,
classProbs = TRUE,
verboseIter = FALSE,
savePredictions = TRUE,
allowParallel=TRUE)
mlModel <- train(x = trainX,
y = refactoredTrainY,
method = "gbm",
preProcess = c("scale","center"),
trControl = ctrl,
verbose = FALSE,
metric = "ROC",
tuneGrid = caretTuneGrid)
predProbs[ii] <- list(predict(mlModel, newdata = testX, type = "prob"))
predClass[ii] <- as.character(predict(mlModel, newdata = testX, type = "raw"))
varImpBestModelDF <- as.data.frame(varImp( mlModel$finalModel, scale = FALSE ))
varImpBestModelDF2 <- rownames_to_column(varImpBestModelDF, "Taxa")
varImpBestModelDF2Ordered <- varImpBestModelDF2[order(-varImpBestModelDF2$Overall),]
colnames(varImpBestModelDF2Ordered)[2] <- "varImp"
varImpBestModelDF2OrderedNonzero <- varImpBestModelDF2Ordered[varImpBestModelDF2Ordered$varImp != 0,]
varImpBestModelDF2OrderedNonzeroList[[ii]] <- varImpBestModelDF2OrderedNonzero
rm(mlModel)
}
loocvPreds <- cbind(obs = factor(obsClass,
levels = classes),
pred = factor(predClass,
levels = classes),
do.call(rbind,predProbs))
# multiClassSummaryStats <- multiClassSummary(loocvPreds, lev = classes)
# print(multiClassSummaryStats)
multiClassSummaryStats[[jj]] <- multiClassSummary(loocvPreds, lev = classes)
print(multiClassSummaryStats[[jj]])
filenameROC <- paste0(filenameString,"__ROC.png")
filenamePR <- paste0(filenameString,"__PR.png")
filenameROCData <- paste0(filenameString,"__Data__ROC.csv")
filenamePRData <- paste0(filenameString,"__Data__PR.csv")
filenameSink <- paste0(filenameString,"__CM.txt")
predProbs <- loocvPreds[,DTs[1]]
fg <- predProbs[loocvPreds$obs == DTs[1]]
bg <- predProbs[loocvPreds$obs == DTs[2]]
prroc_roc <- roc.curve(scores.class0 = fg, scores.class1 = bg, curve = T)
prroc_pr <- pr.curve(scores.class0 = fg, scores.class1 = bg, curve = T, rand.compute=T)
png(filename=filenameROC, width = 6, height = 4, units = 'in', res = 300)
plot(prroc_roc)
dev.off()
png(filename=filenamePR, width = 6, height = 4, units = 'in', res = 300)
plot(prroc_pr)
dev.off()
rocCurveData <- cbind(as.data.frame(prroc_roc$curve), DT1 = DTs[1], DT2 = DTs[2])
prCurveData <- cbind(as.data.frame(prroc_pr$curve), DT1 = DTs[1], DT2 = DTs[2])
write.table(prCurveData, sep=",", file = filenamePRData, col.names = FALSE)
write.table(rocCurveData, sep=",", file = filenameROCData, col.names = FALSE)
}
print(confusionMatrix(loocvPreds$obs, loocvPreds$pred))
multiClassSummaryStatsDist <- data.frame(do.call(rbind, multiClassSummaryStats))
sink(filenameSink)
print(print(confusionMatrix(loocvPreds$obs, loocvPreds$pred)))
sink()
}
nsclc_skcm <- loocvDTs(snmData = snmDataKrakenCFDecontamDPQC,
samplingSize = 25,
DTs = c("NSCLC","SKCM"),
caretTuneGrid = defaultGBMGrid)
loocvPreds
loocvDTs <- function(snmData, samplingSize = 15, DTs, caretTuneGrid = defaultGBMGrid,
filenameString = paste(DTs,collapse = "__"), HvsCFlag = FALSE){
if(HvsCFlag){
metaTmpX <- droplevels(metadataPSMatchedDPQCFiltered[(metadataPSMatchedDPQCFiltered$disease_type_consol %in% DTs),])
metaTmpX$disease_type_consol <- metaTmpX$HvsC
classes <- gsub(" ","",levels(metaTmpX$disease_type_consol))
} else{
metaTmpX <- droplevels(metadataPSMatchedDPQCFiltered[(metadataPSMatchedDPQCFiltered$disease_type_consol %in% DTs),])
classes <- gsub(" ","",DTs)
}
# Do LOOCV model building and testing
multiClassSummaryStats <- list()
multiClassSummaryStatsDist <- list()
numKFold <- 4
numResampleIter <- 1
metaData <- metaTmpX
snmData <- snmData # dataPSUniqueDecontamQC #
iterSize <- 1
for(jj in 1:iterSize){
metadataSimSampled <- as.data.frame(stratified(metaData,
group = "disease_type_consol",
size = samplingSize,
keep.rownames = TRUE,
replace = FALSE,
bothSets = FALSE))
rownames(metadataSimSampled) <- metadataSimSampled$rn
mlDataY <- metadataSimSampled
mlDataX <- snmData[rownames(mlDataY),]
dim(mlDataY)[1] == dim(mlDataX)[1] # Sanity check
# Create data partitions
# set.seed(42)
indexSuper <- 1:dim(mlDataY)[1]
predProbs <- list()
obsClass <- vector()
predClass <- vector()
varImpBestModelDF2OrderedNonzeroList <- list()
for(ii in 1:length(indexSuper)){
print(sprintf("Iteration: %d/%d", ii, length(indexSuper)))
index <- indexSuper[ii]
# print(index)
trainX <- mlDataX[-index,]
trainY <- mlDataY[-index,]$disease_type_consol
testX <- mlDataX[index,,drop=FALSE]
testY <- mlDataY[index,,drop=FALSE]$disease_type_consol
# print(testY)
refactoredTrainY <- factor(gsub('([[:punct:]])|\\s+','',trainY))
refactoredTestY <- factor(gsub('([[:punct:]])|\\s+','',testY))
obsClass[ii] <- as.character(refactoredTestY)
set.seed(42)
ctrl <- trainControl(method = "repeatedcv",
number = numKFold,
repeats = numResampleIter,
sampling = "up",
summaryFunction = multiClassSummary,
classProbs = TRUE,
verboseIter = FALSE,
savePredictions = TRUE,
allowParallel=TRUE)
mlModel <- train(x = trainX,
y = refactoredTrainY,
method = "gbm",
preProcess = c("scale","center"),
trControl = ctrl,
verbose = FALSE,
metric = "ROC",
tuneGrid = caretTuneGrid)
predProbs[ii] <- list(predict(mlModel, newdata = testX, type = "prob"))
predClass[ii] <- as.character(predict(mlModel, newdata = testX, type = "raw"))
varImpBestModelDF <- as.data.frame(varImp( mlModel$finalModel, scale = FALSE ))
varImpBestModelDF2 <- rownames_to_column(varImpBestModelDF, "Taxa")
varImpBestModelDF2Ordered <- varImpBestModelDF2[order(-varImpBestModelDF2$Overall),]
colnames(varImpBestModelDF2Ordered)[2] <- "varImp"
varImpBestModelDF2OrderedNonzero <- varImpBestModelDF2Ordered[varImpBestModelDF2Ordered$varImp != 0,]
varImpBestModelDF2OrderedNonzeroList[[ii]] <- varImpBestModelDF2OrderedNonzero
rm(mlModel)
}
loocvPreds <<- cbind(obs = factor(obsClass,
levels = classes),
pred = factor(predClass,
levels = classes),
do.call(rbind,predProbs))
# multiClassSummaryStats <- multiClassSummary(loocvPreds, lev = classes)
# print(multiClassSummaryStats)
multiClassSummaryStats[[jj]] <- multiClassSummary(loocvPreds, lev = classes)
print(multiClassSummaryStats[[jj]])
filenameROC <- paste0(filenameString,"__ROC.png")
filenamePR <- paste0(filenameString,"__PR.png")
filenameROCData <- paste0(filenameString,"__Data__ROC.csv")
filenamePRData <- paste0(filenameString,"__Data__PR.csv")
filenameSink <- paste0(filenameString,"__CM.txt")
predProbs <- loocvPreds[,DTs[1]]
fg <- predProbs[loocvPreds$obs == DTs[1]]
bg <- predProbs[loocvPreds$obs == DTs[2]]
prroc_roc <- roc.curve(scores.class0 = fg, scores.class1 = bg, curve = T)
prroc_pr <- pr.curve(scores.class0 = fg, scores.class1 = bg, curve = T, rand.compute=T)
png(filename=filenameROC, width = 6, height = 4, units = 'in', res = 300)
plot(prroc_roc)
dev.off()
png(filename=filenamePR, width = 6, height = 4, units = 'in', res = 300)
plot(prroc_pr)
dev.off()
rocCurveData <- cbind(as.data.frame(prroc_roc$curve), DT1 = DTs[1], DT2 = DTs[2])
prCurveData <- cbind(as.data.frame(prroc_pr$curve), DT1 = DTs[1], DT2 = DTs[2])
write.table(prCurveData, sep=",", file = filenamePRData, col.names = FALSE)
write.table(rocCurveData, sep=",", file = filenameROCData, col.names = FALSE)
}
print(confusionMatrix(loocvPreds$obs, loocvPreds$pred))
multiClassSummaryStatsDist <- data.frame(do.call(rbind, multiClassSummaryStats))
sink(filenameSink)
print(print(confusionMatrix(loocvPreds$obs, loocvPreds$pred)))
sink()
}
nsclc_skcm <- loocvDTs(snmData = snmDataKrakenCFDecontamDPQC,
samplingSize = 25,
DTs = c("NSCLC","SKCM"),
caretTuneGrid = defaultGBMGrid)
loocvPreds
?confusionMatrix
print(confusionMatrix(loocvPreds$pred, loocvPreds$obs))
?roc.curve
loocvDTs_Mod <- function(snmData, samplingSize = 15, DTs, caretTuneGrid = defaultGBMGrid,
filenameString = paste(DTs,collapse = "__"), HvsCFlag = FALSE){
if(HvsCFlag){
metaTmpX <- droplevels(metadataPSMatchedDPQCFiltered[(metadataPSMatchedDPQCFiltered$disease_type_consol %in% DTs),])
metaTmpX$disease_type_consol <- metaTmpX$HvsC
classes <- gsub(" ","",levels(metaTmpX$disease_type_consol))
} else{
metaTmpX <- droplevels(metadataPSMatchedDPQCFiltered[(metadataPSMatchedDPQCFiltered$disease_type_consol %in% DTs),])
classes <- gsub(" ","",DTs)
}
# Do LOOCV model building and testing
multiClassSummaryStats <- list()
multiClassSummaryStatsDist <- list()
numKFold <- 4
numResampleIter <- 1
metaData <- metaTmpX
snmData <- snmData # dataPSUniqueDecontamQC #
iterSize <- 1
for(jj in 1:iterSize){
metadataSimSampled <- as.data.frame(stratified(metaData,
group = "disease_type_consol",
size = samplingSize,
keep.rownames = TRUE,
replace = FALSE,
bothSets = FALSE))
rownames(metadataSimSampled) <- metadataSimSampled$rn
mlDataY <- metadataSimSampled
mlDataX <- snmData[rownames(mlDataY),]
dim(mlDataY)[1] == dim(mlDataX)[1] # Sanity check
# Create data partitions
# set.seed(42)
indexSuper <- 1:dim(mlDataY)[1]
predProbs <- list()
obsClass <- vector()
predClass <- vector()
varImpBestModelDF2OrderedNonzeroList <- list()
for(ii in 1:length(indexSuper)){
print(sprintf("Iteration: %d/%d", ii, length(indexSuper)))
index <- indexSuper[ii]
# print(index)
trainX <- mlDataX[-index,]
trainY <- mlDataY[-index,]$disease_type_consol
testX <- mlDataX[index,,drop=FALSE]
testY <- mlDataY[index,,drop=FALSE]$disease_type_consol
# print(testY)
refactoredTrainY <- factor(gsub('([[:punct:]])|\\s+','',trainY))
refactoredTestY <- factor(gsub('([[:punct:]])|\\s+','',testY))
obsClass[ii] <- as.character(refactoredTestY)
set.seed(42)
ctrl <- trainControl(method = "repeatedcv",
number = numKFold,
repeats = numResampleIter,
sampling = "up",
summaryFunction = multiClassSummary,
classProbs = TRUE,
verboseIter = FALSE,
savePredictions = TRUE,
allowParallel=TRUE)
mlModel <- train(x = trainX,
y = refactoredTrainY,
method = "gbm",
preProcess = c("scale","center"),
trControl = ctrl,
verbose = FALSE,
metric = "ROC",
tuneGrid = caretTuneGrid)
predProbs[ii] <- list(predict(mlModel, newdata = testX, type = "prob"))
predClass[ii] <- as.character(predict(mlModel, newdata = testX, type = "raw"))
varImpBestModelDF <- as.data.frame(varImp( mlModel$finalModel, scale = FALSE ))
varImpBestModelDF2 <- rownames_to_column(varImpBestModelDF, "Taxa")
varImpBestModelDF2Ordered <- varImpBestModelDF2[order(-varImpBestModelDF2$Overall),]
colnames(varImpBestModelDF2Ordered)[2] <- "varImp"
varImpBestModelDF2OrderedNonzero <- varImpBestModelDF2Ordered[varImpBestModelDF2Ordered$varImp != 0,]
varImpBestModelDF2OrderedNonzeroList[[ii]] <- varImpBestModelDF2OrderedNonzero
rm(mlModel)
}
loocvPreds <<- cbind(obs = factor(obsClass,
levels = classes),
pred = factor(predClass,
levels = classes),
do.call(rbind,predProbs))
# multiClassSummaryStats <- multiClassSummary(loocvPreds, lev = classes)
# print(multiClassSummaryStats)
multiClassSummaryStats[[jj]] <- multiClassSummary(loocvPreds, lev = classes)
print(multiClassSummaryStats[[jj]])
filenameROC <- paste0(filenameString,"__ROC.png")
filenamePR <- paste0(filenameString,"__PR.png")
filenameROCData <- paste0(filenameString,"__Data__ROC.csv")
filenamePRData <- paste0(filenameString,"__Data__PR.csv")
filenameSink <- paste0(filenameString,"__CM.txt")
predProbs <- loocvPreds[,DTs[1]]
fg <- predProbs[loocvPreds$obs == DTs[1]]
bg <- predProbs[loocvPreds$obs == DTs[2]]
prroc_roc <- roc.curve(scores.class0 = fg, scores.class1 = bg, curve = T)
prroc_pr <- pr.curve(scores.class0 = fg, scores.class1 = bg, curve = T, rand.compute=T)
png(filename=filenameROC, width = 6, height = 4, units = 'in', res = 300)
plot(prroc_roc)
dev.off()
png(filename=filenamePR, width = 6, height = 4, units = 'in', res = 300)
plot(prroc_pr)
dev.off()
rocCurveData <- cbind(as.data.frame(prroc_roc$curve), DT1 = DTs[1], DT2 = DTs[2])
prCurveData <- cbind(as.data.frame(prroc_pr$curve), DT1 = DTs[1], DT2 = DTs[2])
write.table(prCurveData, sep=",", file = filenamePRData, col.names = FALSE)
write.table(rocCurveData, sep=",", file = filenameROCData, col.names = FALSE)
}
print(confusionMatrix(loocvPreds$pred, loocvPreds$obs))
multiClassSummaryStatsDist <- data.frame(do.call(rbind, multiClassSummaryStats))
sink(filenameSink)
print(confusionMatrix(loocvPreds$pred, loocvPreds$obs))
sink()
}
nsclc_skcm <- loocvDTs_Mod(snmData = snmDataKrakenCFDecontamDPQC,
samplingSize = 15,
DTs = c("Control","PRAD","NSCLC"),
caretTuneGrid = defaultGBMGrid)
nsclc_skcm
DTH3 <- loocvDTs_Mod(snmData = snmDataKrakenCFDecontamDPQC,
samplingSize = 15,
DTs = c("Control","PRAD","NSCLC"),
caretTuneGrid = defaultGBMGrid)
numCores <- detectCores()
registerDoMC(cores=numCores)
?multiClassSummary
setwd("~/Google Drive/AAA_UCSD_Research/AAA_Knight_Lab/AAA_Projects/AAA_TCGA/AAA_Final_Analysis/A_RShiny_App_Final_Feb2020")
shiny::runApp()
runApp()
runApp()
runApp()
